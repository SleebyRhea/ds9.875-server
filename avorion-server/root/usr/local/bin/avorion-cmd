#! /usr/bin/env bash

# void say <string, ...>
#	Ouput the strings passed to stdout and return
function say () {
	echo "$1"
	exit 1
}

# int die <options> <string, ...>
#	Output the strings passed to stdout then exit
#	with status code 1 (or the code given w
function die () {
	echo "$1"
	exit 1
}


##############
# Pre-Checks #
##############

# Die if there are no arguments passed
[[ $# -eq 0 ]] \
	|| die "Usage: avorion-cmd <options> <parameters>"

# Die if tmux is not installed
command -v tmux >/dev/null 2>&1 \
	|| die "avorion-cmd requires tmux to function! Please run apt install -y tmux"

# Die if we are running in a screen or tmux session.
# TODO: Migrate check to functions that operate on TMUX sessions
if ! { [[ -z "$TMUX" ]] && [[ ! "$TERM" =~ ^(screen|tmux) ]] && [[ -z "$TMUX_PANE" ]]; }; then
	die "This command should not be run from within a Screen/Tmux session"
fi

# Die if the settings file is NOT present
if [[ ! -f /etc/avorionsettings.conf ]]; then
   die "Cant source Avorion settings! </etc/avorionsettings.conf>  file not found!"
fi

#####

function __validate_settings_conf () {
	local -A __conf_vars
	__conf_vars[AVORION_ADMIN_GRP]='[a-z]{4,}'
	__conf_vars[AVORION_SERVICEDIR]='[a-zA-Z0-9_\-]{1,}'
	__conf_vars[AVORION_BINDIR]='[a-zA-Z0-9_\-]{1,}'
	__conf_vars[AVORION_STEAMID]='[0-9]{2,}'

	grep -qcvE "^(($(printf '%s' "${!__conf_vars[*]}" | tr ' ' '|'))=.*|\\s*)" >/dev/null \
		|| return 1

	local i=0
	while read -r __l; do
		local __err="Configuration error on line ${i} of /etc/avorionsettings.conf"
		
		# Set line count
		((i++))
		
		# We dont case about blank lines, so skip those
		[[ "$__l" =~ ^\s*$ ]] \
			&& continue
		
		[[ "$__l" =~ ^([\s]+)=([\s]+)$ ]] \
			|| die "${__err} -- Bad syntax: <${__l}>"

		[[ -z "${__conf_vars["${BASH_REMATCH[1]}"]}" ]] \
			&& die "${__err} -- Invalid setting: <${BASH_REMATCH[1]}>"

		[[ "${BASH_REMATCH[2]}" =~ ${__conf_vars[${BASH_REMATCH[1]}]} ]] \
			|| die "${__err} -- Invalid option passed: <$__l>"

	done < /etc/avorionsettings.conf
	
	return 0
}

source /etc/avorionsettings.conf

if [[ ! "$(groups)" =~ (^$AVORION_ADMIN_GRP | $AVORION_ADMIN_GRP | $AVORION_ADMIN_GRP$) ]] && [[ "$(id -u)" != 0 ]]; then
	die "This command can only be run by a ds9 admin or root."
fi

_clr="$(tput sgr0)";    _bld="$(tput bold)"
_wht="$(tput setaf 7)"; _grn="$(tput setaf 2)"
_red="$(tput setaf 1)"; _yel="$(tput setaf 3)"

_tmuxconf=/etc/avorioncmd-tmux.conf
_tmuxcmd="$(which tmux)"

if [[ ! "$1" =~ (help|update|validate|showinstances) ]]; then
	_tmuxsess="$2"
	_tmuxsess="${_tmuxsess//[ _]/\-}"
	_tmuxsess="${_tmuxsess//[^a-zA-Z0-9\-]/}"

	if [[ "$_tmuxsess" =~ ^[sS][tT][eE][aA][mM] ]]; then
		_tmuxsock="${AVORION_SERVICEDIR}/sockets/steamcmd.sock"
	elif systemctl status avorion@"$_tmuxsess" >/dev/null 2>&1 || systemctl status "${_tmuxsess}.service" >/dev/null 2>&1; then
		_tmuxsock="${AVORION_SERVICEDIR}/sockets/${_tmuxsess}.sock"
	else
		echo "$_tmuxsess is not a valid instance"
		exit 1
	fi
fi

case "$1" in 
	attach)
		"$_tmuxcmd" -f "${_tmuxconf}" -S "$_tmuxsock" attach || exit 1
		exit 0
		;;
	
	view)
		"$_tmuxcmd" -f "${_tmuxconf}" -S "$_tmuxsock" attach -r || exit 1
		exit 0
		;;
	
	exec)
		shift; shift
		"$_tmuxcmd" -f "${_tmuxconf}" -S "$_tmuxsock" send-keys "$@" ENTER \; attach -r || exit 1
		exit 0
		;;
	
	update)
		[[ -d "/tmp/avorion/updatingavorion.lock" ]] \
			&& die "Update process already running"

		mkdir -p /tmp/updatingavorion.lock >/dev/null 2>&1 \
			|| echo "Unable to create avorion lockfile! Check /tmp usage."

		_units="$(systemctl list-units 'avorion@*' | grep 'loaded active running' | awk '{print $1}')"
		
		[[ -n "${_units}" ]] && {
			while read _inst; do
				_inst="${_inst%%.service}"; _inst="${_inst##*avorion@}"
				"$_tmuxcmd" -f "${_tmuxconf}" -S "${AVORION_SERVICEDIR}/sockets/${_inst}.sock" \
					send-keys "/say Prepping for server updates. Prepare for reboot" ENTER "/save" ENTER
			done <<< "${_units}"
		}

		echo "Updates locked."

		"$_tmuxcmd" -f "${_tmuxconf}" -S "${AVORION_SERVICEDIR}/sockets/steamcmd.sock" \
			send-keys "force_install_dir \"${AVORION_SERVICEDIR}/${AVORION_BINDIR}\"" ENTER "app_update \"$AVORION_STEAMID\" validate" ENTER \; \
			pipe-pane "exec cat > ${AVORION_SERVICEDIR}/steamupdate.log" \;

		tail -n 100 -f "${AVORION_SERVICEDIR}/steamupdate.log" | sed -r '/^[\s]*(Success|Failure)/ q'
		
		"$_tmuxcmd" -f "${_tmuxconf}" -S "${AVORION_SERVICEDIR}/sockets/steamcmd.sock" pipe-pane \;

		[[ -n "${_units}" ]] && {
			while read _inst; do
				_inst="${_inst%%.service}"; _inst="${_inst##*avorion@}"
				"$_tmuxcmd" -f "${_tmuxconf}" -S "${AVORION_SERVICEDIR}/sockets/${_inst}.sock" \
					send-keys "/say Rebooting server for updates." ENTER "/save" ENTER "/stop"
			done <<< "${_units}"
		}

		rm -rf /tmp/avorion/updatingavorion.lock >/dev/null 2>&1 || {
			echo "Unable to remove lockfile. Please ensure that the update was finished successfully."
			exit 1
		}
		
		echo "Updates unlocked"

		exit 0
		;;
	
	showinstances)
		if (( ! "$(find "${AVORION_SERVICEDIR}/sockets" -name '*.sock' | wc -l)" > 0 )); then
			echo "No service instances running"
			exit 1
		fi

		echo "${_bld}${_wht}DeepSpace 9.875 Service Instances:${_clr}"

		find "${AVORION_SERVICEDIR}/sockets" -name '*.sock' -printf '%f\n' | sort | while read -r _sock; do
			local _instance="${_sock%%.sock*}"
		
			if systemctl list-units avorion@* 2>&1 | grep -q "^avorion@${_instance}.service " >/dev/null 2>&1 ; then
				systemctl status avorion@"${_instance}" >/dev/null 2>&1 \
					&& echo "${_instance} (avorion@${_instance}) -- ${_grn}Online${_clr}" \
					|| echo "${_instance} (avorion@${_instance}) -- ${_red}Offline${_clr}"

			elif [[ "$_instance" =~ ^steam(cmd|cli)$ ]]; then
				systemctl status "${_instance}" >/dev/null 2>&1 \
					&& echo "${_instance} (steamcmd.service) -- ${_grn}Online${_clr}" \
					|| echo "${_instance} (steamcmd.service) -- ${_red}Offline${_clr}"

			else
				if [[ -f "/etc/systemd/system/${_instance}.service" ]]; then
					systemctl status "${_instance}" >/dev/null 2>&1 \
						&& echo "${_instance} -- ${_grn}Online${_clr}" \
						|| echo "${_instance} -- ${_red}Offline${_clr}"
				fi
			fi
		done
		;;

	backup)
		echo "TODO: Unimplemented"
		exit 0
		;;

	resetsector)
		echo "TODO: Unimplemented"
		exit 0
		;;

	help)
		echo "Usage: avorion-cmd <option> <parameters>"
		echo "Options:"
		printf '\t%s\n' \
			"help: This help text" \
			"update: Force a full Avorion server update. Note that this brings the server down following the update." \
			"showinstances: Display a listing of all Avorion/Steam instances"
		
		printf '\t%s\n\t\t%s\n' \
			"attach: Attach to a service instance." \
				"Example: ${_grn}avorion-cmd attach <instance>${_clr}" \
			"view: Attach to a service instance in read-only mode." \
				"Example: ${_grn}avorion-cmd view <instance>${_clr}"

		printf '\t%s\n\t\t%s\n\t\t%s\n' \
			"exec: Run the specified commands in the service supplied" \
				"Example: ${_grn}avorion-cmd exec <instance/service> <COMMANDS>" \
				"${_red}WARNING:${_clr} Unfinished/Untested and may be buggy, please dont use this for large Lua scripts commands until further tested." \
			"backup: Force a backup run of the given instance" \
				"Example: ${_grn}avorion-cmd backup <instance>${_clr}" \
				"${_yel}NOTICE:${_clr} Unimplemented at this time." \
			"resetsector: Reset the given sector/sectors for a server instance" \
				"Example: ${_grn}avorion-cmd resetsector <instance> x y${_clr}" \
				"${_yel}NOTICE:${_clr} Unimplemented at this time."
			
			exit 0
		;;

	?)
		printf '%s\n' "Invalid argument passed: <$(printf '%q' "$1")>"
		exit 1
		;;
esac
