#! /usr/bin/env bash

CMDVERS='0.5.1'
CMDNAME="$(basename "$0")"
EDATE="$(date %s)"

# void say <string, ...>
#	Ouput the strings passed to stdout and return
function say () {
	for _l in "$@"; do
		printf '%s\n' "${_l}"
	done
	return 0
}

# bool dbssay <string, ...>
#	If the script is currently in debug mode, `say`
#	the arguments passed to this function. Otherwise,
#	return code 1
function dbgsay () {
	[[ "${VERBOSE}" == 1 ]] \
		&& say "$@" \
		|| return 1
}

# int die <options> <string>
#	Output the strings passed to stdout then exit
#	with status code 1 (or the code given with -c)
function die () {
	local _code=1
	if [[ "$1" -eq '-c' ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
		_code="$2"
		shift; shift
	fi

	say "Error: $1"
	exit "$_code"
}

# bool yesno <string>
#	Get a yes or no response from the user and
#	return accordingly (0 for yes, 1 for no).
#	If a string is passed, provide the user with
#	that string as a prompt.
function yesno () {
	local _prompt _answer
	_prompt="${1-[Yes/No]}"

	while true; do
		printf '%s' "${_prompt}> "
		read _answer

		case "${_answer}" in
			[yY][eE][sS] | [yY])
				return 0
				;;
			[nN][oO] | [nN])
				return 1
				;;
			?)
				say "Please enter yes or no."
				;;
		esac
	done
}

# int plural <int>
#	Given an int, print an s to the caller if said
#	int does not equal 1
function plural () {
	if [[ "$1" =~ ^[0-9]+$ ]]; then
		(( $1 != 1 )) || {
			printf '%s' 's'
			return 0
		}
		return 0
	fi

	die "Function \`plural\` recieved <$1> rather than an int"
}
# bool __check_requirements <void>
#	Checks required software versions and exits if either
#	the required software is not present in $PATH or if it
#	does not meet the minimum version requirements.
function __check_requirements () {
	local -A _requires
	local _prog _arg _string

	# Required version strings, prepended with the argument
	# that will invoke them.
	_requires[tmux]='-V=^[0-9]?[2-9].[0-9].*'
	_requires[bash]='--verson=^GNU bash, version [0-9]?[4-9].*'
	_requires[sed]='--version=^sed (GNU sed) [0-9]?[4-9].*'

	for _prog in "${!_requires[@]}"; do
		_arg="${_requires["$_prog"]%%=*}"
		_string="${_requires["$_prog"]##*=}"

		command -v $_prog \
			|| die "${_prog} is required but not installed!"

		[[ "$("$_prog" "$_arg")" =~ $_string ]] \
			|| die "${_prog} doesnt meet the minimum version requirements"
	done
}

# int __validate_process_exec <ARGV>
#	Run various pre-checks prior to running the main
#	script body to ensure that the process execution
#	is both valid, and that all of the required pkgs
#	have been installed. If any of these pre-checks
#	fail, exit the script with error code 1 and give
#	an explanation.
function __assert_valid_execution () {
	__check_requirements

	# Die if there are no arguments passed
	[[ $# -eq 0 ]] \
		|| die "Usage: avorion-cmd <options> <parameters>"

	# Die if we are running in a screen or tmux session.
	# TODO: Migrate check to functions that operate on TMUX sessions
	if ! { [[ -z "$TMUX" ]] && [[ ! "$TERM" =~ ^(screen|tmux) ]] && [[ -z "$TMUX_PANE" ]]; }; then
		die "This command should not be run from within a Screen/Tmux session"
	fi

	# Make sure the user is part of the admin group or is root. The 
	# regex is used here to prevent unintentionally matching groups
	# that contain the group string but dont exactly match it. Since
	# root should be able to do anything, we also check for id 0
	if [[ ! "$(groups)" =~ (^$AVORION_ADMIN_GRP | $AVORION_ADMIN_GRP | $AVORION_ADMIN_GRP$) ]] && [[ "$(id -u)" != 0 ]]; then
		die "This command can only be run by a ${AVORION_ADMIN_GRP} or root."
	fi
}

# bool __assert_valid_user_input <string>
#	Check the string given for bash symbols
#	and return error if any are found.
function __assert_valid_user_input () {
	[[ "$1" =~ [/\\$\&@#\`~=+{}\[\]|\'\"] ]] \
		&& return 1 \
		|| return 0
}

# int __validate_setting_conf <void>
#	Run validation checks on the configuration file.
#	This function checks all of the non-blank lines
#	present in the conf file and ensures that they
#	are both valid configs, and that the settings
#	provided are valid.
function __validate_setting_conf () {
	[[ -f /etc/avorionsettings.conf ]] \
		|| die "Avorion configuration file not found"

	local -A __conf_vars
	local __bad_symbols __err
	__bad_symbols="[\\&^s\(\)%\[\]\#@!<>\'\",;:\{\}]"
	__conf_vars[AVORION_ADMIN_GRP]='^[a-z]+$'
	__conf_vars[AVORION_SERVICEDIR]='^/[a-zA-Z0-9_\-]+$'
	__conf_vars[AVORION_BINDIR]='^/[a-zA-Z0-9_\-]+$'
	__conf_vars[AVORION_STEAMID]='^[0-9]+$'

	# Leaving this here for now, but this used to check for invalid options
	# being set in the configuration file
	# grep -qcvE "^(($(printf '%s' "${!__conf_vars[*]}" | tr ' ' '|'))=.*|\\s*)" /etc/avorionsettings.conf >/dev/null \
	#	|| return 1

	local i=0
	while read -r __l; do
		# Set current line count
		((i++))
		
		__err="Configuration error on line ${i} of /etc/avorionsettings.conf"
		
		# We dont care about blank lines, so skip those
		[[ "${__l}" =~ ^[ \t]*$ ]] && continue

		# Ensure the line contains no invalid symbols
		[[ "${__l}" =~ $__bad_symbols ]] \
			&& die "${__err} -- Invalid chars present: <${__l}>"
		
		# Ensure that the variable declaration syntax is valid.
		# We also use this to assign the captured strings to the
		# BASH_REMATCH environment variable.
		[[ "${__l}" =~ ^([^ \t]+)=([^ \t]+)$ ]] \
			|| die "${__err} -- Bad syntax: <${__l}>"

		# Ensure that the variable being declared is actually
		# a setting that we will be making use of.
		[[ -z "${__conf_vars["${BASH_REMATCH[1]}"]}" ]] \
			&& die "${__err} -- Invalid setting: <${BASH_REMATCH[1]}>"

		# Make sure that the values given to the variable match a
		# set syntax.
		#
		# TODO: Perform some deeper checks here. IE, we would
		#       want to catch things like having the admin grp
		#       set to sudo.
		[[ "${BASH_REMATCH[2]}" =~ ${__conf_vars[${BASH_REMATCH[1]}]} ]] \
			|| die "${__err} -- Invalid assignment: <${__l}>"

	done < /etc/avorionsettings.conf
	
	return 0
}

# bool __set_tmux_instance <string>
#	Provided a string, verify that the instance
#	is a valid (and active) tmux controlled instance
#	and set the tmux socket and session globals
function __set_tmux_instance () {
	[[ -z "$1" ]] \
		|| return 1

	# Strip bad chars from user input
	_tmuxsess="$1"
	_tmuxsess="${_tmuxsess//[ _]/\-}"
	_tmuxsess="${_tmuxsess//[^a-zA-Z0-9\-]/}"

	# Catch references to steam and force set the instance to steamcmd
	if [[ "$_tmuxsess" =~ ^[sS][tT][eE][aA][mM] ]]; then
		_tmuxsock="${AVORION_SERVICEDIR}/sockets/steamcmd.sock"

	# If the instance is either an Avorion instance or a valid service
	# file, then use that and set the tmux session
	elif systemctl status avorion@"$_tmuxsess" >/dev/null 2>&1 || systemctl status "${_tmuxsess}" >/dev/null 2>&1; then
		_tmuxsock="${AVORION_SERVICEDIR}/sockets/${_tmuxsess}.sock"

	else
		echo "$_tmuxsess is not a valid instance"
		exit 1
	fi
}

# void __set_globals <void>
#	Set various global values, and declare
#	other unset globals
function __set_globals () {
	declare VERBOSE=0
	declare _tmuxsess _tmuxsock _instdir
	
	readonly _clr="$(tput sgr0)"
	readonly _bld="$(tput bold)"
	readonly _red="$(tput setaf 1)"
	readonly _grn="$(tput setaf 2)"
	readonly _yel="$(tput setaf 3)"
	readonly _wht="$(tput setaf 7)"
	readonly _tmuxconf=/etc/avorioncmd-tmux.conf
	readonly _tmuxcmd="$(which tmux)"
	readonly _regex_sector_arg='^-?[0-9]{1,3}:-?[0-9]{1,3}(--?[0-9]{1,3}:-?[0-9]{1,3}|)$'
	readonly _regex_sector_num='-?[0-9]{1,3}'
}

# void __perform_update <void>
#	Perform a server update for the Avorion server
#	software. Stops all current server instances,
#	updates the server, and restarts the stopped
#	instances if any were present. Can also be used
#	to install avorion if the server was not already
#	present on the system.
function __perform_update () {

	# Die if there is already an update running.
	[[ -d "/tmp/avorion/updatingavorion.lock" ]] \
		&& die "Update process already running"

	mkdir -p /tmp/updatingavorion.lock >/dev/null 2>&1 \
		|| die "Unable to create avorion lockfile! Check /tmp usage."

	# Make sure that the update lock is removed following this
	# scripts end
	trap 'rm -rf /tmp/avorion/updatingavorion.lock;echo "Updates unlocked"' EXIT INT TERM
	local _units _inst

	# Queries the systemd bus for active avorion@ instances and saves them
	_units="$(systemctl list-units 'avorion@*' | grep -E '^avorion@[^\s]+.service loaded active running' | awk '{print $1}')"
	
	# If there were any active instances, stop them.
	[[ -n "${_units}" ]] && {
		while read _inst; do
			_inst="${_inst%%.service}"
			echo "Stopping <${__inst}>"
			sudo -n systemctl stop "${__inst}"
		done <<< "${_units}"
	}

	echo "Updates locked."

	# Send the update command (with validation) to the steamcmd instance. We also
	# have tmux pipe the output of the command to the file $AVORION_SERVICEDIR/steamupdate.log
	"$_tmuxcmd" -f "${_tmuxconf}" -S "${AVORION_SERVICEDIR}/sockets/steamcmd.sock" \
		send-keys "force_install_dir \"${AVORION_SERVICEDIR}/${AVORION_BINDIR}\"" ENTER "app_update \"$AVORION_STEAMID\" validate" ENTER \; \
		pipe-pane "exec cat > ${AVORION_SERVICEDIR}/steamupdate.log" \;

	# As a workaround, since we have the command above operating concurrently,
	# we follow the new log output until it reaches a stage in which we know
	# that the Steam updater has completed. Then, we exit using the `q` sed command.
	tail -n 100 -f "${AVORION_SERVICEDIR}/steamupdate.log" 2>&1 | sed -r '/^(Success!|Failure)/ q'
	echo 'Done'
	
	# Stop outputting to a logfile
	"$_tmuxcmd" -f "${_tmuxconf}" -S "${AVORION_SERVICEDIR}/sockets/steamcmd.sock" pipe-pane \;

	# If any instances were up prior to the update, re-start them
	[[ -n "${_units}" ]] && {
		while read _inst; do
			__inst="${_inst%%.service}"
			echo "Starting <${__inst}>"
			sudo -n systemctl start "${_inst}"
		done <<< "${_units}"
	}

	exit 0
}

function __perform_backup () {
	true
}

# bool __perform_sector_reset <options> <int/string, ...>
#	Delete the sectors passed. The sectors can either be defined
#	individually or as part of a range using:
#	
#	int:int-int:int
#	
#	With the first set being the range of x values, and the second
#	being the range of y values.
#	Valid options include:
#		--backup	Force take backups
function __perform_sector_reset () {
	local _save _sector _bakdir _secdir
	local _x1 _x2 _y1 _y2
	local -a _sector_array
	_save=0; 
	_secdir="${AVORION_SERVICEDIR}/${_tmuxsess}/sectors/${EDATE}"

	# If the first argument is `--backups` then we don't need to confirm backups, we assume yes.
	# We also use that opportunity to shift the positional arguments to the left. Since `shift`
	# will return true, and only runs if the correct argument is found, this is still valid.
	if { [[ "$1" -eq '--backup' ]] && shift; } || yesno "Would you like to save backups?"; then
		_save=1
		_bakdir="${AVORION_SERVICEDIR}/${_tmuxsess}/sector_backup"
		if [[ ! -d "${_bakdir}" ]]; then
			mkdir -p "${_bakdir}" \
				|| die "Unable to create backup directory! Aborting."
		fi
	fi

	# While there are still arguments to process
	while (( $# > 0 )); do

		# Only follow this path if the given argument is a single
		# coord. Shift and continue execution in the next loop 
		# after the sector is queued
		if [[ "$1" =~ ^-?[0-9]{1,3}:-?[0-9]{1,3}$ ]]; then
			_sector="${1//:/_}"
			[[ -f "${_secdir}/${_sector}" ]] || {
				dbgsay "Sector <${_sector}> doesn't exist. Skipping."
				shift; continue
			}
			dbgsay "Queueing sector: <${_sector}>"
			_sector_array+=( "${_secdir}/${_sector}" )
			shift; continue

		# Only follow this path if the argument given is the defined range
		# of coordinates. Unlike before where we simply replace the `:` with
		# a `_`, here we make use of Bash's ability to store regex capture
		# an array (BASH_REMATCH) to generate two for loops to queue the
		# passed sectors.
		elif [[ "$1" =~ ^(-?[0-9]{1,3}):(-?[0-9]{1,3})-(-?[0-9]{1,3}):(-?[0-9]{1,3})$ ]]; then
			_x1="${BASH_REMATCH[1]}"; _x2="${BASH_REMATCH[2]}"
			_y1="${BASH_REMATCH[3]}"; _y2="${BASH_REMATCH[4]}"
			for _x in {"$_x1".."$_x2"}; do
				for _y in {"$_y1".."$_y2"}; do
					[[ -f "${_secdir}/${_x}_${_y}" ]] || {
						dbgsay "Sector <${_x}_${_y}> doesn't exist. Skipping."
						continue
					}

					dbgsay "Queuing sector: <${_x}_${_y}>"
					_sector_array+=( "${_secdir}/${_sector}" )
				done
			done

		# Die if the "sector" given is just invalid.
		else
			die "Bad sector formatting: <${1}>. Aborting."
		fi
	done

	# Obviously we dont need to continue if there are no
	# sectors to process
	(( ${#_sector_array[@]} < 1 )) && {
		say "No sectors to be processed. Aborting."
		exit 0
	}
	
	# Confirmation of sector deletion. the `plural` function
	# does exactly what it looks like it does. If the number
	# is NOT one, return an `s`
	yesno "WARNING: Delete ${#_sector_array[@]} sector$(plural ${#_sector_array[@]})?" || {
		say "Aborted due to user input"
		exit 0
	}

	# For every sector queued, backup if specified, and then
	# delete.
	for _sector in "${_sector_array[@]}"; do
		(( $_save == 1 )) \
			&& cp "${_sector}" "$_bakdir"
		
		rm "${_sector}"
	done
}

# bool __perform_config_edits <string, string>
#	Given a file and an instance, create a temporary
#	file in which to operate on and install it in the
#	correct instance directory. Note that this stops
#	the instance before installing the edits, as Avorion
#	will overwrite the edits made on restart.
function __perform_config_edits () {
	__assert_valid_user_input "$2" \
		|| die "Invalid file passed: <$2>" \
	
	local __instance="$1"
	local __file="$2"
	local __inst_file="${AVORION_SERVICEDIR}/${__instance}/${__file}"
	local __temp_file="/tmp/avorion-cmd/${__instance}/${__file}.tmp"
	local __editor

	[[ -w "${__inst_file}" ]] || {
		say "Unable to edit file: <${__inst_file}>"

		[[ -f "${__inst_file}" ]] \
			|| die "File does not exist."
	
		die "File is not writable. Are the permissions correct?"	
	}

	if [[ -d "/tmp/avorion-cmd/${__instance}" ]]; then 
		[[ -f "${__temp_file}" ]] \
			&& die "Config file is already open by another"
	else
		mkdir -p "/tmp/avorion-cmd/${1}" >/dev/null 2>&1 \
			|| die "Unable to generate tmp directory /tmp/avorion-cmd/${1}"
	fi

	cp "${__inst_file}" "${__temp_file}" >/dev/null \
		|| die "Unable to generate temp file for editting"

	if [[ -z "${VISUAL}" ]]; then
		if [[ -z "${EDITOR}" ]]; then
			command -v nano >/dev/null 2>&1 \
				|| __editor="vi" \
				&& __editor="nano"
		else
			__editor="${EDITOR}"
		fi
	else
		__editor="${VISUAL}"
	fi

	trap "rm ${__temp_file} >/dev/null 2>&1 && echo 'Removed tempfile' || echo 'Unable to remove tempfile'" EXIT SIGTERM

	"${__editor}" "${__temp_file}" \
		|| die "Unable to write to <${__temp_file}>"
	
	echo "Stopping avorion@${__instance}.service..."
	sudo systemctl stop avorion@"${__instance}" >/dev/null

	mv "$__temp_file" "$__inst_file" \
		|| say "Unable to make changes to instance settings"

	echo "Starting avorion@${__instance}.service..."
	sudo systemctl start avorion@"${__instance}" \
		|| die "Unable to start!!"
}

# void __show_service_instances <void>
#	Locate and verify current online and offline
#	instances. Then, print them (formatted) to the screen
#	and exit
function __show_service_instances () {
	if (( ! "$(find "${AVORION_SERVICEDIR}/sockets" -name '*.sock' | wc -l)" > 0 )); then
		echo "No service instances running"
		exit 1
	fi

	echo "${_bld}${_wht}DeepSpace 9.875 Service Instances:${_clr}"

	find "${AVORION_SERVICEDIR}/sockets" -name '*.sock' -printf '%f\n' | sort | while read -r _sock; do
		local _instance="${_sock%%.sock*}"
	
		if systemctl list-units 'avorion@*' 2>&1 | grep -q "^avorion@${_instance}.service " >/dev/null 2>&1 ; then
			systemctl status avorion@"${_instance}" >/dev/null 2>&1 \
				&& echo "${_instance} (avorion@${_instance}) -- ${_grn}Online${_clr}" \
				|| echo "${_instance} (avorion@${_instance}) -- ${_red}Offline${_clr}"

		elif [[ "$_instance" =~ ^steam(cmd|cli)$ ]]; then
			systemctl status "${_instance}" >/dev/null 2>&1 \
				&& echo "${_instance} (steamcmd.service) -- ${_grn}Online${_clr}" \
				|| echo "${_instance} (steamcmd.service) -- ${_red}Offline${_clr}"

		else
			if [[ -f "/etc/systemd/system/${_instance}.service" ]]; then
				systemctl status "${_instance}" >/dev/null 2>&1 \
					&& echo "${_instance} -- ${_grn}Online${_clr}" \
					|| echo "${_instance} -- ${_red}Offline${_clr}"
			fi
		fi
	done
}

function main () {
	__validate_setting_conf && source /etc/avorionsettings.conf
	__assert_valid_execution
	__set_globals

	local __err_bad_inst='Invalid instance passed:'

	for _arg do
		shift
		[[ "${_arg}" == --debug ]] && {
			VERBOSE=1
			continue
		}
		set -- "$@" "${_arg}"
	done

	case "$1" in
		attach)
			__set_tmux_instance "$2" \
				|| die "${__err_bad_inst} <$2>"

			"$_tmuxcmd" -f "${_tmuxconf}" -S "$_tmuxsock" attach \
				|| exit 1 \
				&& exit 0
			;;
		
		lock)
			__set_tmux_instance "$2" \
				|| die "${__err_bad_inst} <$2>"
			exit 0
			;;

		view)
			__set_tmux_instance "$2" \
				|| die "${__err_bad_inst} <$2>"

			"$_tmuxcmd" -f "${_tmuxconf}" -S "$_tmuxsock" attach -r \
				|| exit 1 \
				&& exit 0
			;;
		
		exec)
			__set_tmux_instance "$2" \
				|| die "${__err_bad_inst} <$2>"

			shift; shift
			"$_tmuxcmd" -f "${_tmuxconf}" -S "$_tmuxsock" send-keys "$@" ENTER \; attach -r \
				|| exit 1 \
				&& exit 0
			;;
		
		update)
			__perform_update \
				|| exit 1 \
				&& exit 0
			;;
		
		showinstances|-I)
			__show_service_instances \
				|| exit 1 \
				&& exit 0
			;;

		backup)
			__get_instance_dir \
				|| die "${__err_bad_inst} <$2>"

			__perform_backup "$_instdir" \
				|| exit 1 \
				&& exit 0
			;;

		config)
			__set_tmux_instance "$2" \
				|| die "${__err_bad_inst} <$2>"

			[[ "$_tmuxsess" =~ ^[sS][tT][eE][aA][mM] ]] \
				|| die "Steam configs are not managed by ${CMDNAME}"

			__perform_config_edits "$_tmuxsess" "$3" \
				|| exit 1 \
				&& exit 0
			;;

		resetsector)
			__set_tmux_instance "$2" \
				|| die "${__err_bad_inst} <$2>"

			shift; shift
			
			for _secarg in "${@}"; do
				# Regex to match the following cases: x, y, or x1:y1-x2:y2
				# while supporting negatives.
				[[ "$_secarg" =~ ${_regex_sector_arg} ]] \
					|| die "Invalid Sector Parameter: <${_secarg}>"
			done

			__perform_sector_reset "$@"\
				|| exit 1 \
				&& exit 0
			;;

		usage|--usage|-u)
			say "Avorion Manager v${CMDVERS}"
			say "Usage: ${CMDNAME} <command> <optons> <parameters>"
			exit 0
			;;

		--help|help|-h)
			cat << _EOF_
Avorion Manager v${CMDVERS}
Usage: ${CMDNAME} <command> <optons> <parameters>

Commands:
	showinstances --instances -I
		Display a listing of all Avorion/Steam instances

	help --help -h
		This help text
	
	usage --usage -u
		Print the usage text
	
	version --version -V
		Print versioning information
	
	start
		Start the given Avorion instance
		${_grn}${CMDNAME} start <instance>${_clr}
	
	restart
		Restart the given instance
		${_grn}${CMDNAME} restart <instance>${_clr}
	
	stop
		Stop the given instance. Unlike when used in game, this will prevent
		the game from restarting following the 30 second window. Use this when
		configuration changes need to be made. Alternatively, use ${_grn}config${_clr}
		instead.
		${_grn}${CMDNAME} stop <instance>${_clr}
	
	exec
		Pass the given commands into the instance server session.
		${_grn}${CMDNAME} exec <instance> <commands>${_clr}
		${_red}WARNING:${_clr} Unfinished/Untested and may be buggy, please dont use this for large Lua scripts commands until further tested.
	
	config
		Edit the specified configuration file for the Avorion instance given.
		${_grn}${CMDNAME} config <instance> <file>${_clr}
		
		Avorion Config Files:
			server.ini
			modconfig.lua
			whitelist.txt
			blacklist.txt
			admin.xml
			ipblacklist.txt
			group-whitelist.txt
	
	resetsectors
		Reset the given sectors or range of sectors.
		${_grn}${CMDNAME} resetsectors <instance> <x:y, ...>${_clr}
		${_grn}${CMDNAME} resetsectors <instance> <x:x-y:y>
		${_yel}NOTICE: Not currently implemented${_clr}
	
	backup
		Take a backup of the given instance.
		${_grn}${CMDNAME} backup <instance>${_clr}
		${_yel}NOTICE: Not currently implemented${_clr}
	
	update
		Force a game update. Not usually necessary as simply restarting the server
		should accomplish this.
_EOF_
			exit 0
			;;

		-V|--version)
			echo "${CMDVERS}"
			exit 0
			;;

		?)
			printf '%s\n' "Invalid argument passed: <$1>"
			exit 1
			;;
	esac
}

main "$@"
