#! /usr/bin/env bash

CMDVERS='0.5.1'
CMDNAME="$(basename "$0")"

# void say <string, ...>
#	Ouput the strings passed to stdout and return
function say () {
	echo "$1"
	return 0
}

# int die <options> <string, ...>
#	Output the strings passed to stdout then exit
#	with status code 1 (or the code given w
function die () {
	say "Error: $1"
	exit 1
}

# bool yesno <string>
#	Get a yes or no response from the user and
#	return accordingly (0 for yes, 1 for no).
#	If a string is passed, provide the user with
#	that string as a prompt.
function yesno () {
	local _prompt _answer
	_prompt="${1-[Yes/No]> }"

	while true; do
		printf '%s' "${_prompt}"
		read _answer

		case "${_answer}" in
			[yY][eE][sS] | [yY])
				return 0
				;;
			[nN][oO] | [nN])
				return 1
				;;
			?)
				say "Please enter yes or no."
				;;
		esac
	done
}

# int __validate_process_exec <ARGV>
#	Run various pre-checks prior to running the main
#	script body to ensure that the process execution
#	is both valid, and that all of the required pkgs
#	have been installed. If any of these pre-checks
#	fail, exit the script with error code 1 and give
#	an explanation.
function __assert_valid_execution () {
	# Die if there are no arguments passed
	[[ $# -eq 0 ]] \
		|| die "Usage: avorion-cmd <options> <parameters>"

	# Die if tmux is not installed
	command -v tmux >/dev/null 2>&1 \
		|| die "avorion-cmd requires tmux to function! Please run apt install -y tmux"

	# Die if we are running in a screen or tmux session.
	# TODO: Migrate check to functions that operate on TMUX sessions
	if ! { [[ -z "$TMUX" ]] && [[ ! "$TERM" =~ ^(screen|tmux) ]] && [[ -z "$TMUX_PANE" ]]; }; then
		die "This command should not be run from within a Screen/Tmux session"
	fi

	# Make sure the user is part of the admin group or is root
	if [[ ! "$(groups)" =~ (^$AVORION_ADMIN_GRP | $AVORION_ADMIN_GRP | $AVORION_ADMIN_GRP$) ]] && [[ "$(id -u)" != 0 ]]; then
		die "This command can only be run by a DS9 admin or root."
	fi
}

# bool __assert_valid_user_input <string>
#	Check the string given for bash symbols
#	and return error if any are found.
function __assert_valid_user_input () {
	[[ "$1" =~ [/\\$\&@#\`~=+{}\[\]|\'\"] ]] \
		&& return 1 \
		|| return 0
}

# int __validate_setting_conf <void>
#	Run validation checks on the configuration file.
#	This function checks all of the non-blank lines
#	present in the conf file and ensures that they
#	are both valid configs, and that the settings
#	provided are valid.
function __validate_setting_conf () {
	[[ -f /etc/avorionsettings.conf ]] \
		|| die "Avorion configuration file not found"

	local -A __conf_vars
	local __bad_symbols
	__bad_symbols="[\\&^s\(\)%\[\]\#@!<>\'\",;:\{\}]"
	__conf_vars[AVORION_ADMIN_GRP]='^[a-z]+$'
	__conf_vars[AVORION_SERVICEDIR]='^/[a-zA-Z0-9_\-]+$'
	__conf_vars[AVORION_BINDIR]='^/[a-zA-Z0-9_\-]+$'
	__conf_vars[AVORION_STEAMID]='^[0-9]+$'

	# Leaving this here for now, but this used to check for invalid options
	# being set in the configuration file
	# grep -qcvE "^(($(printf '%s' "${!__conf_vars[*]}" | tr ' ' '|'))=.*|\\s*)" /etc/avorionsettings.conf >/dev/null \
	#	|| return 1

	local i=0
	while read -r __l; do
		local __err="Configuration error on line ${i} of /etc/avorionsettings.conf"
		
		# Set line count
		((i++))
		
		# We dont care about blank lines, so skip those
		[[ "$__l" =~ ^\s*$ ]] \
			&& continue

		# Ensure the line contains no invalid symbols
		[[ "$__l" =~ $__bad_symbols ]] \
			&& die "${__err} -- Invalid chars present: <${__l}>"
		
		# Ensure that the variable declaration syntax is valid
		[[ "$__l" =~ ^([^ \t\n]+)=([^ \t]+)$ ]] \
			|| die "${__err} -- Bad syntax: <${__l}>"

		# Ensure that the variable being declared is actually
		# a setting that we will be making use of.
		[[ -z "${__conf_vars["${BASH_REMATCH[1]}"]}" ]] \
			&& die "${__err} -- Invalid setting: <${BASH_REMATCH[1]}>"

		# Make sure that the values given to the variable match a
		# set syntax.
		#
		# TODO: Perform some deeper checks here. IE, we would
		#       want to catch things like having the admin grp
		#       set to sudo.
		[[ "${BASH_REMATCH[2]}" =~ ${__conf_vars[${BASH_REMATCH[1]}]} ]] \
			|| die "${__err} -- Invalid assignment: <$__l>"

	done < /etc/avorionsettings.conf
	
	return 0
}

# bool __set_tmux_instance <string>
#	Provided a string, verify that the instance
#	is a valid (and active) tmux controlled instance
#	and set the tmux socket and session globals
function __set_tmux_instance () {
	[[ -z "$1" ]] \
		|| return 1

	# Strip bad chars from user input
	_tmuxsess="$1"
	_tmuxsess="${_tmuxsess//[ _]/\-}"
	_tmuxsess="${_tmuxsess//[^a-zA-Z0-9\-]/}"

	if [[ "$_tmuxsess" =~ ^[sS][tT][eE][aA][mM] ]]; then
		_tmuxsock="${AVORION_SERVICEDIR}/sockets/steamcmd.sock"
	elif systemctl status avorion@"$_tmuxsess" >/dev/null 2>&1 || systemctl status "${_tmuxsess}.service" >/dev/null 2>&1; then
		_tmuxsock="${AVORION_SERVICEDIR}/sockets/${_tmuxsess}.sock"
	else
		echo "$_tmuxsess is not a valid instance"
		exit 1
	fi
}

# void __set_globals <void>
#	Set various global values, and declare
#	other unset globals
function __set_globals () {
	readonly _clr="$(tput sgr0)"
	readonly _bld="$(tput bold)"
	readonly _red="$(tput setaf 1)"
	readonly _grn="$(tput setaf 2)"
	readonly _yel="$(tput setaf 3)"
	readonly _wht="$(tput setaf 7)"
	readonly _tmuxconf=/etc/avorioncmd-tmux.conf
	readonly _tmuxcmd="$(which tmux)"

	declare _tmuxsess _tmuxsock _instdir
}

# void __perform_update <void>
#	Perform a server update for the Avorion server
#	software. Stops all current server instances,
#	updates the server, and restarts the stopped
#	instances.
function __perform_update () {

	# Die if there is already an update running.
	[[ -d "/tmp/avorion/updatingavorion.lock" ]] \
		&& die "Update process already running"

	mkdir -p /tmp/updatingavorion.lock >/dev/null 2>&1 \
		|| die "Unable to create avorion lockfile! Check /tmp usage."

	# Make sure that the update lock is removed following this
	# scripts end
	trap 'rm -rf /tmp/avorion/updatingavorion.lock;echo "Updates unlocked"' EXIT INT TERM
	local _units _inst

	# Queries the systemd bus for active avorion@ instances,
	# and saves them.
	_units="$(systemctl list-units 'avorion@*' | grep -E '^avorion@[^\s]+.service loaded active running' | awk '{print $1}')"
	
	# If there were any active instances, stop them.
	[[ -n "${_units}" ]] && {
		while read _inst; do
			_inst="${_inst%%.service}"
			echo "Stopping <${__inst}>"
			sudo -n systemctl stop "${__inst}"
		done <<< "${_units}"
	}

	echo "Updates locked."

	# Send the update command (with validation) to the steamcmd instance. We also
	# have tmux pipe the output of the command to the file $AVORION_SERVICEDIR/steamupdate.log
	"$_tmuxcmd" -f "${_tmuxconf}" -S "${AVORION_SERVICEDIR}/sockets/steamcmd.sock" \
		send-keys "force_install_dir \"${AVORION_SERVICEDIR}/${AVORION_BINDIR}\"" ENTER "app_update \"$AVORION_STEAMID\" validate" ENTER \; \
		pipe-pane "exec cat > ${AVORION_SERVICEDIR}/steamupdate.log" \;

	# As a workaround, since we have the command above operating concurrently,
	# we following the new logoutput until it reaches a stage in which we know
	# that the Steam updater has completed. Then, we exit using the `q` sed command.
	tail -n 100 -f "${AVORION_SERVICEDIR}/steamupdate.log" 2>&1 | sed -r '/^(Success!|Failure)/ q'
	echo 'Done'
	
	# Stop outputing to a logfile
	"$_tmuxcmd" -f "${_tmuxconf}" -S "${AVORION_SERVICEDIR}/sockets/steamcmd.sock" pipe-pane \;

	# If any instances were up prior to the update, re-start them
	[[ -n "${_units}" ]] && {
		while read _inst; do
			__inst="${_inst%%.service}"
			echo "Starting <${__inst}>"
			sudo -n systemctl start "${_inst}"
		done <<< "${_units}"
	}

	exit 0
}

function __perform_backup () {
	true
}

function __perform_sector_reset () {
	true
}

# bool __perform_config_edits <string, string>
#	Given a file and an instance, create a temporary
#	file in which to operate on and install it in the
#	correct instance directory. Note that this stops
#	the instance before installing the edits, as Avorion
#	will overwrite the edits made on restart.
function __perform_config_edits () {
	__assert_valid_user_input "$2" \
		|| die "Invalid file passed: <$2>" \
	
	local __instance="$1"
	local __file="$2"
	local __inst_file="${AVORION_SERVICEDIR}/${__instance}/${__file}"
	local __temp_file="/tmp/avorion-cmd/${__instance}/${__file}.tmp"
	local __editor

	[[ -w "${__inst_file}" ]] || {
		say "Unable to edit file: <${__inst_file}>"

		[[ -f "${__inst_file}" ]] \
			|| die "File does not exist."
	
		die "File is not writable. Are the permissions correct?"	
	}

	if [[ -d "/tmp/avorion-cmd/${__instance}" ]]; then 
		[[ -f "${__temp_file}" ]] \
			&& die "Config file is already open by another"
	else
		mkdir -p "/tmp/avorion-cmd/${1}" >/dev/null 2>&1 \
			|| die "Unable to generate tmp directory /tmp/avorion-cmd/${1}"
	fi

	cp "${__inst_file}" "${__temp_file}" >/dev/null \
		|| die "Unable to generate temp file for editting"

	if [[ -z "${VISUAL}" ]]; then
		if [[ -z "${EDITOR}" ]]; then
			command -v nano >/dev/null 2>&1 \
				|| __editor="vi" \
				&& __editor="nano"
		else
			__editor="${EDITOR}"
		fi
	else
		__editor="${VISUAL}"
	fi

	trap "rm ${__temp_file} >/dev/null 2>&1 && echo 'Removed tempfile' || echo 'Unable to remove tempfile'" EXIT SIGTERM

	"${__editor}" "${__temp_file}" \
		|| die "Unable to write to <${__temp_file}>"
	
	echo "Stopping avorion@${__instance}.service..."
	sudo systemctl stop avorion@"${__instance}" >/dev/null

	mv "$__temp_file" "$__inst_file" \
		|| say "Unable to make changes to instance settings"

	echo "Starting avorion@${__instance}.service..."
	sudo systemctl start avorion@"${__instance}" \
		|| die "Unable to start!!"
}

# void __show_service_instances <void>
#	Locate and verify current online and offline
#	instances. Then, print them (formatted) to the screen
#	and exit
function __show_service_instances () {
	if (( ! "$(find "${AVORION_SERVICEDIR}/sockets" -name '*.sock' | wc -l)" > 0 )); then
		echo "No service instances running"
		exit 1
	fi

	echo "${_bld}${_wht}DeepSpace 9.875 Service Instances:${_clr}"

	find "${AVORION_SERVICEDIR}/sockets" -name '*.sock' -printf '%f\n' | sort | while read -r _sock; do
		local _instance="${_sock%%.sock*}"
	
		if systemctl list-units avorion@* 2>&1 | grep -q "^avorion@${_instance}.service " >/dev/null 2>&1 ; then
			systemctl status avorion@"${_instance}" >/dev/null 2>&1 \
				&& echo "${_instance} (avorion@${_instance}) -- ${_grn}Online${_clr}" \
				|| echo "${_instance} (avorion@${_instance}) -- ${_red}Offline${_clr}"

		elif [[ "$_instance" =~ ^steam(cmd|cli)$ ]]; then
			systemctl status "${_instance}" >/dev/null 2>&1 \
				&& echo "${_instance} (steamcmd.service) -- ${_grn}Online${_clr}" \
				|| echo "${_instance} (steamcmd.service) -- ${_red}Offline${_clr}"

		else
			if [[ -f "/etc/systemd/system/${_instance}.service" ]]; then
				systemctl status "${_instance}" >/dev/null 2>&1 \
					&& echo "${_instance} -- ${_grn}Online${_clr}" \
					|| echo "${_instance} -- ${_red}Offline${_clr}"
			fi
		fi
	done
}

function main () {
	__validate_setting_conf && source /etc/avorionsettings.conf
	__assert_valid_execution
	__set_globals

	local __err_bad_inst='Invalid instance passed:'

	case "$1" in
		-a|a|attach)
			__set_tmux_instance "$2" \
				|| die "${__err_bad_inst} <$2>"

			"$_tmuxcmd" -f "${_tmuxconf}" -S "$_tmuxsock" attach \
				|| exit 1 \
				&& exit 0
			;;
		
		-v|v|view)
			__set_tmux_instance "$2" \
				|| die "${__err_bad_inst} <$2>"

			"$_tmuxcmd" -f "${_tmuxconf}" -S "$_tmuxsock" attach -r \
				|| exit 1 \
				&& exit 0
			;;
		
		-e|e|exec)
			__set_tmux_instance "$2" \
				|| die "${__err_bad_inst} <$2>"

			shift; shift
			"$_tmuxcmd" -f "${_tmuxconf}" -S "$_tmuxsock" send-keys "$@" ENTER \; attach -r \
				|| exit 1 \
				&& exit 0
			;;
		
		-U|update)
			__perform_update \
				|| exit 1 \
				&& exit 0
			;;
		
		--show-instances|showinstances|instances)
			__show_service_instances \
				|| exit 1 \
				&& exit 0
			;;

		--backup|backup)
			__get_instance_dir \
				|| die "${__err_bad_inst} <$2>"

			__perform_backup "$_instdir" \
				|| exit 1 \
				&& exit 0
			;;

		config|-C|--config)
			__set_tmux_instance "$2" \
				|| die "${__err_bad_inst} <$2>"

			[[ "$_tmuxsess" =~ ^[sS][tT][eE][aA][mM] ]] \
				|| die "Steam configs are not managed by avorion-cmd"

			__perform_config_edits "$_tmuxsess" "$3" \
				|| exit 1 \
				&& exit 0
			;;

		--reset-sector|resetsector)
			__set_tmux_instance "$2" \
				|| die "${__err_bad_inst} <$2>"

			shift; shift
			
			for _secarg in "${@}"; do
				# Regex to match the following cases: x, y, or x1:y1-x2:y2
				# while supporting negatives.
				[[ "$_secarg" =~ (^(-|)[0-9]{1,3}$|^(-|)[0-9]{1,3}:(-|)[0-9]{1,3}-(-|)[0-9]{1,3}:(-|)[0-9]{1,3}$) ]] \
					|| die "Invalid Sector Parameter: <${_secarg}>"
			done

			__perform_sector_reset "$@"\
				|| exit 1 \
				&& exit 0
			;;

		--help|help|-h)
			cat << _EOF_
Avorion Manager v${CMDVERS}
Usage: ${CMDNAME} <command> <optons> <parameters>

Commands:
	showinstances
		Display a listing of all Avorion/Steam instances
	
	help
		This help text
	
	usage
		Print the usage text
	
	start
		Start the given Avorion instance
		${_grn}${CMDNAME} start <instance>${_clr}
	
	restart
		Restart the given instance
		${_grn}${CMDNAME} restart <instance>${_clr}
	
	stop
		Stop the given instance. Unlike when used in game, this will prevent
		the game from restarting following the 30 second window. Use this when
		configuration changes need to be made. Alternatively, use ${_grn}config${_clr}
		instead.
		${_grn}${CMDNAME} stop <instance>${_clr}
	
	exec
		Pass the given commands into the instance server session.
		${_grn}${CMDNAME} exec <instance> <commands>${_clr}
		${_red}WARNING:${_clr} Unfinished/Untested and may be buggy, please dont use this for large Lua scripts commands until further tested.
	
	config
		Edit the specified configuration file for the Avorion instance given.
		${_grn}${CMDNAME} config <instance> <file>${_clr}
		
		Avorion Config Files:
			server.ini
			modconfig.lua
			whitelist.txt
			blacklist.txt
			admin.xml
			ipblacklist.txt
			group-whitelist.txt
	
	resetsectors
		Reset the given sectors or range of sectors.
		${_grn}${CMDNAME} resetsectors <instance> <x:y, ...>${_clr}
		${_grn}${CMDNAME} resetsectors <instance> <x:y-x:y>
		${_yel}NOTICE: Not currently implemented${_clr}
	
	backup
		Take a backup of the given instance.
		${_grn}${CMDNAME} backup <instance>${_clr}
		${_yel}NOTICE: Not currently implemented${_clr}
	
	update
		Force a game update. Not usually necessary as simply restarting the server
		should accomplish this.
_EOF_
			exit 0
			;;
		-V|--version)
			echo "${CMDVERS}"
			exit 0
			;;

		?)
			printf '%s\n' "Invalid argument passed: <$1>"
			exit 1
			;;
	esac
}

main "$@"
