#! /usr/bin/env bash

AVORIONCMD=/usr/local/bin/avorion-cmd

function main() {
	__validate_setting_conf &&\
		source /etc/avorionsettings.conf
	
	local __active_units=( $(getactive) )
	local __failed=0

	$AVORIONCMD exec +all --cron '\say Server restart in 1 hour'; sleep 15m
	$AVORIONCMD exec +all --cron '\say Server restart in 45 minutes'; sleep 15m
	$AVORIONCMD exec +all --cron '\say Server restart in 30 minutes'; sleep 15m
	$AVORIONCMD exec +all --cron '\say Server restart in 15 minutes'; sleep 5m
	$AVORIONCMD exec +all --cron '\say Server restart in 10 minutes'; sleep 5m

	for n in {5..1}; do
		$AVORIONCMD exec +all --cron "\\say Server restart in $n minute$(plural $n)"
		sleep 1m
	done

	for n in {30..1}; do
		$AVORIONCMD exec +all --cron "\\say Server restart in $n second$(plural $n)"
		sleep 1
	done

	$AVORIONCMD stop +all --cron

	if ! __perform_rsync; then
		echo "Failed to perform rsync!"
		((__failed++))
	fi
	
	if (( "${#__active_units[@]}" > 0 )); then
		for __inst in "${__active_units[@]}"; do
			__inst="${_inst%%.service}"
			__inst="${_inst##avorion@}"
			$AVORIONCMD start "$__inst" --cron
		done
	fi

	if (( __failed > 0 )); then
		echo "Failed to perform backup rsync. Please check status!"
		exit 1
	fi
}

#
#
#
#
function __perform_rsync () {
	local __fail=0

	rsync --chown="$AVORION_USER":"$AVORION_ADMIN_GRP" "$AVORION_SERVICEDIR"/ "$AVORION_BAKDIR"/ ||\
		((__fail++))

}

# bool __validate_setting_conf <void>
#	Validates the avorionsettings configuration, and makes sure that
#	sourcing it will not break anything. If the file passes, return.
#	Otherwise, kill the script.
function __validate_setting_conf () {
	[[ -f /etc/avorionsettings.conf ]] ||\
		die "Avorion configuration file not found"

	local -A __conf_vars
	local __bad_symbols __err
	__bad_symbols="[\\&^s\(\)%\[\]\#@!<>\'\",;:\{\}]"
	__conf_vars[AVORION_ADMIN_GRP]='^[a-z][a-z]*$'
	__conf_vars[AVORION_USER]='^[a-z][a-z]*$'
	__conf_vars[AVORION_SERVICEDIR]='^/[a-zA-Z0-9_\-][a-zA-Z0-9_\-\/]*$'
	__conf_vars[AVORION_BINDIR]='^[a-zA-Z0-9_\-\/][a-zA-Z0-9_\-\/]*$'
	__conf_vars[AVORION_BAKDIR]='^\/[a-zA-Z0-9_\-\/][a-zA-Z0-9_\-\/]*$'
	__conf_vars[AVORION_STEAMID]='^[0-9][0-9]*$'
	__conf_vars[STEAMCMD_BIN]='^(/[a-zA-Z0-9_\-\/][a-zA-Z0-9_\-\/\.]*[a-zA-Z0-9]|steamcmd)$'

	# Leaving this here for now, but this used to check for invalid options
	# being set in the configuration file
	# grep -qcvE "^(($(printf '%s' "${!__conf_vars[*]}" | tr ' ' '|'))=.*|\\s*)" /etc/avorionsettings.conf >/dev/null \
	#	|| return 1

	local i=0
	while read -r __l; do
		# Set current line count
		((i++))
		
		__err="Configuration error on line ${i} of /etc/avorionsettings.conf"
		
		# We dont care about blank lines and comments, so skip those
		[[ "${__l}" =~ ^[[:space:]]*#*$ ]] && continue

		# Ensure the line contains no invalid symbols
		[[ "${__l}" =~ $__bad_symbols ]] &&\
			die "${__err} -- Invalid chars present: <$( printf '%q' "${__l}") >"
		
		# Ensure that the variable declaration syntax is valid.
		# We also use this to assign the captured strings to the
		# BASH_REMATCH environment variable (bash does this automatically)
		[[ "${__l}" =~ ^([^[:space:]][^[:space:]]*)=([^[:space:]][^[:space:]]*)$ ]] ||\
			die "${__err} -- Bad syntax: <$( printf '%q' "${__l}")>"

		# Ensure that the variable being declared is actually
		# a setting that we will be making use of.
		# 
		# NOTE: About the wierd printf '%q' syntax, %q is an option that
		# can be given to the printf Bash builtin that will automatically
		# escape out any special characters. In this context, it is used
		# to prevent special characters from potentially executing. This
		# is also accomplished above, but I am paranoid
		[[ -z "${__conf_vars[$( printf '%q' "${BASH_REMATCH[1]}" )]}" ]] &&\
			die "${__err} -- Invalid setting: <$( printf '%q' "${BASH_REMATCH[1]}" )>"

		# Make sure that the values given to the variable match a
		# set syntax.
		#
		# TODO: Perform some deeper checks here. IE, we would
		#       want to catch things like having the admin group
		#       set to sudo.
		[[ "$( printf '%q' "${BASH_REMATCH[2]}" )" =~ ${__conf_vars[$( printf '%q' "${BASH_REMATCH[1]}" )]} ]] ||\
			die "${__err} -- Invalid assignment: <$( printf '%q' "${__l}")>"

	done < /etc/avorionsettings.conf
	
	return 0
}

#@@@@@@@@@@@#
# Utilities #
#@@@@@@@@@@@#

# int die <options> <string>
#	Output the strings passed to stdout then exit
#	with status code 1 (or the code given with -c)
function die () {
	local _code=1
	if [[ "$1" == '-c' ]] && [[ "$2" =~ ^[0-9][0-9]*$ ]]; then
		_code="$2"
		shift; shift
	fi

	printf "Error: $1\n"
	exit "$_code"
}

# bool yesno <string>
#	Get a yes or no response from the user and
#	return accordingly (0 for yes, 1 for no).
#	If a string is passed, provide the user with
#	that string as a prompt.
function yesno () {
	local _prompt _answer
	_prompt="${1-Yes/No}"

	while true; do
		printf "[${_prompt}]> "
		read -r _answer
		case "${_answer}" in
			[yY][eE][sS] | [yY] )
				return 0
				;;
			[nN][oO] | [nN] )
				return 1
				;;
			?)
				printf "Please enter yes or no.\n"
				;;
		esac
	done
}

# int plural <int>
#	Given an int, print an s to the caller if said
#	int does not equal 1
function plural () {
	if [[ "$1" =~ ^[0-9]+$ ]]; then
		if (( $1 != 1 )); then
			printf '%s' 's'
			return 0
		fi
		return 0
	fi

	die "Function <plural> recieved <$1> rather than an int"
}

function getactive () {
	local __unit_string='^[[:space:]]*avorion@[^[:space:]][^[:space:]]*.service[[:space:]][[:space:]]*loaded[[:space:]][[:space:]]*active[[:space:]][[:space:]]*running'
	systemctl list-units 'avorion@*' | grep "$__unit_string" | awk '{print $1}' 2>/dev/null | sed 's,^avorion@,,; s,\.service$,,'
}
main "$@"
